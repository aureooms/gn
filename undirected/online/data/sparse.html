<!DOCTYPE html><html lang="en"><head><title>undirected/online/data/sparse</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../"><meta name="groc-document-path" content="undirected/online/data/sparse"><meta name="groc-project-path" content="js/src/undirected/online/data/sparse.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-gn"><link rel="stylesheet" type="text/css" media="all" href="../../../assets/style.css"><script type="text/javascript" src="../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-gn/blob/master/js/src/undirected/online/data/sparse.js">js/src/undirected/online/data/sparse.js</a></div></div><div id="document"><div class="segment"></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO should take a linked list prototype as template parameter
     in order to simplify the implementation and allow better
     parametrization as well as clarify the code</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO an explicit satelite data storage emplacement should be allocated
     in the vertices and edges in order to allow a more flexible usage
     of this code</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> sparse_graph_t = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Object constructor</p>
<p>The main entry points in the graph object are the two dummy nodes [beg] and [end].
Those allow us to write more generic code by handling corner cases implicitly.
They allow the addition of a single vertex to the graph in O(1).
Remark : Indeed the behaviour we want to get is the behaviour of a dll (doubly linked list).</p>
<p>vertices are small arrays where</p>
<p>[0] = the vertex label lab()
[1] = the vertex predecessor pred()
[2] = the vertex successor succ()
[3] = the edge list pointer e()</p>
<p>For the set vertices that have not been removed from the graph,
we define the &#39;youngest&#39; vertex as the most recently added vertex of this set
and we define the &#39;oldest&#39; vertex as the least recently added vertex of this set</p>
<h1 id="invariants">Invariants</h1>
<p>Given the graph is not empty:</p>
<blockquote>
<p>[end][1] = pred of end = the youngest vertex
[beg][2] = succ of beg = the oldest vertex</p>
</blockquote>
<p>Given a vertex v</p>
<blockquote>
<p>v[1][2] = succ of pred of v = v
v[2][1] = pred of succ of v = v</p>
</blockquote></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> graph = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

		<span class="hljs-keyword">this</span>.beg = [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>];
		<span class="hljs-keyword">this</span>.end = [<span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>.beg, <span class="hljs-literal">null</span>];
		<span class="hljs-keyword">this</span>.beg[<span class="hljs-number">2</span>] = <span class="hljs-keyword">this</span>.end;

		<span class="hljs-keyword">this</span>.ebeg = [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, -<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>];
		<span class="hljs-keyword">this</span>.eend = [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, -<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.ebeg, <span class="hljs-literal">null</span>];
		<span class="hljs-keyword">this</span>.ebeg[<span class="hljs-number">4</span>] = <span class="hljs-keyword">this</span>.eend;

	};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Prototype method to add a vertex to the graph with label h.</p>
<p><p>
The graph is extended</p>
<p>Parameters:</p>
<ul>
<li><strong>h must be a label.</strong><br/>(is the label)</li>
</ul></div></div><div class="code"><div class="wrapper">	graph.prototype.vadd = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( h )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>First the vertex is created and appended at the end of the dll.
Remember [end][1] was the previous last element
which could be [beg] if the graph was empty before the  call.
After the assignation,</p>
<blockquote>
<p>[end][1][1] is the previous [end][1]
[end] and [end][1] are sane
[end][1][1][2] is still pointing to [end]</p>
</blockquote></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.end[<span class="hljs-number">1</span>] = [h, <span class="hljs-keyword">this</span>.end[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.end, [<span class="hljs-literal">null</span>, -<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>update [end][1][1][2] to fix the invariant break</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.end[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-keyword">this</span>.end[<span class="hljs-number">1</span>];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return new vertex</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.end[<span class="hljs-number">1</span>];
	};

	graph.prototype.vdel = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i)</span>{</span>

		<span class="hljs-keyword">this</span>.eitr(i, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span> <span class="hljs-keyword">this</span>.edel(e); });


		i[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = i[<span class="hljs-number">2</span>]; <span class="hljs-comment">// next of pref becomes next</span>
		i[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = i[<span class="hljs-number">1</span>]; <span class="hljs-comment">// prev of next becomes prev</span>

	};

	graph.prototype.eadd = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i, j, w)</span>{</span>

		i[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = [j, w, i[<span class="hljs-number">3</span>], i[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>], <span class="hljs-literal">null</span>];
		<span class="hljs-keyword">if</span>(i[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] !== <span class="hljs-literal">null</span>) i[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = i[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];

		<span class="hljs-keyword">if</span>(j !== i){
			j[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = [i, w, j[<span class="hljs-number">3</span>], j[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>], <span class="hljs-literal">null</span>];
			<span class="hljs-keyword">if</span>(j[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] !== <span class="hljs-literal">null</span>) j[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = j[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];
		}

		<span class="hljs-keyword">this</span>.eend[<span class="hljs-number">3</span>] = [i, j, w, <span class="hljs-keyword">this</span>.eend[<span class="hljs-number">3</span>], <span class="hljs-keyword">this</span>.eend, i[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>], j[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]];

		<span class="hljs-keyword">this</span>.eend[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <span class="hljs-keyword">this</span>.eend[<span class="hljs-number">3</span>];

		i[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = j[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <span class="hljs-keyword">this</span>.eend[<span class="hljs-number">3</span>];

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.eend[<span class="hljs-number">3</span>];

	};

	graph.prototype.edel = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span>{</span>

		e[<span class="hljs-number">5</span>][<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = e[<span class="hljs-number">5</span>][<span class="hljs-number">3</span>];
		<span class="hljs-keyword">if</span>(e[<span class="hljs-number">5</span>][<span class="hljs-number">3</span>] !== <span class="hljs-literal">null</span>) e[<span class="hljs-number">5</span>][<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = e[<span class="hljs-number">5</span>][<span class="hljs-number">2</span>];


		<span class="hljs-keyword">if</span>(e[<span class="hljs-number">6</span>] !== e[<span class="hljs-number">5</span>]){
			e[<span class="hljs-number">6</span>][<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = e[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>];
			<span class="hljs-keyword">if</span>(e[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>] !== <span class="hljs-literal">null</span>) e[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = e[<span class="hljs-number">6</span>][<span class="hljs-number">2</span>];
		}


		e[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = e[<span class="hljs-number">4</span>]; <span class="hljs-comment">// next of pref becomes next</span>
		e[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>] = e[<span class="hljs-number">3</span>]; <span class="hljs-comment">// prev of next becomes prev</span>

	};


	graph.prototype.vitr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn)</span>{</span>

		<span class="hljs-keyword">var</span> i = <span class="hljs-keyword">this</span>.beg[<span class="hljs-number">2</span>];

		<span class="hljs-keyword">while</span>(i !== <span class="hljs-keyword">this</span>.end){

			<span class="hljs-keyword">if</span>(fn.call(<span class="hljs-keyword">this</span>, i)) <span class="hljs-keyword">break</span>;

			i = i[<span class="hljs-number">2</span>];
		}

	};

	graph.prototype.eitr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i, fn, e)</span>{</span>

		<span class="hljs-keyword">if</span>(e === <span class="hljs-literal">undefined</span>) e = i[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];

		<span class="hljs-keyword">while</span>(e !== <span class="hljs-literal">null</span>){

			<span class="hljs-keyword">if</span>(fn.call(<span class="hljs-keyword">this</span>, e[<span class="hljs-number">4</span>], e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>])) <span class="hljs-keyword">return</span> e[<span class="hljs-number">3</span>];

			e = e[<span class="hljs-number">3</span>];
		}

		<span class="hljs-keyword">return</span> e;

	};

	graph.prototype.aeitr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, e)</span>{</span>

		<span class="hljs-keyword">if</span>(e === <span class="hljs-literal">undefined</span>) e = <span class="hljs-keyword">this</span>.ebeg[<span class="hljs-number">4</span>];

		<span class="hljs-keyword">while</span>(e !== <span class="hljs-keyword">this</span>.eend){

			<span class="hljs-keyword">if</span>(fn.call(<span class="hljs-keyword">this</span>, e, e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>])) <span class="hljs-keyword">return</span> e[<span class="hljs-number">4</span>];

			e = e[<span class="hljs-number">4</span>];
		}

		<span class="hljs-keyword">return</span> e;

	};


	graph.prototype.aeend = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.eend; };



	<span class="hljs-keyword">return</span> graph;

};

exports.sparse_graph_t = sparse_graph_t;</div></div></div></div></body></html>