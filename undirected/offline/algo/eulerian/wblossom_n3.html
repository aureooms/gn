<!DOCTYPE html><html lang="en"><head><title>undirected/offline/algo/eulerian/wblossom_n3</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../"><meta name="groc-document-path" content="undirected/offline/algo/eulerian/wblossom_n3"><meta name="groc-project-path" content="js/src/undirected/offline/algo/eulerian/wblossom_n3.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-gn"><link rel="stylesheet" type="text/css" media="all" href="../../../../assets/style.css"><script type="text/javascript" src="../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-gn/blob/master/js/src/undirected/offline/algo/eulerian/wblossom_n3.js">js/src/undirected/offline/algo/eulerian/wblossom_n3.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Adapted from <a href="http://jorisvr.nl/maximummatching.html">http://jorisvr.nl/maximummatching.html</a>
All credit for the implementation goes to Joris van Rantwijk [<a href="http://jorisvr.nl">http://jorisvr.nl</a>].</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong> Original introduction below </strong></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Weighted maximum matching in general graphs.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The algorithm is taken from &quot;Efficient Algorithms for Finding Maximum
Matching in Graphs&quot; by Zvi Galil, ACM Computing Surveys, 1986.
It is based on the &quot;blossom&quot; method for finding augmenting paths and
the &quot;primal-dual&quot; method for finding a matching of maximum weight, both
due to Jack Edmonds.
Some ideas came from &quot;Implementation of algorithms for maximum matching
on non-bipartite graphs&quot; by H.J. Gabow, Standford Ph.D. thesis, 1973.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A C program for maximum weight matching by Ed Rothberg was used extensively
to validate this new code.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> wblossom_n3_t = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">debug, CHECK_OPTIMUM, CHECK_DELTA</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If assigned, DEBUG(str) is called with lots of debug messages.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> DEBUG = debug ? <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>)</span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'DEBUG:'</span>, s); } : <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check delta2/delta3 computation after every substage;
only works on integer weights, slows down the algorithm to O(n^4).</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> (CHECK_DELTA === <span class="hljs-literal">undefined</span>) CHECK_DELTA = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check optimality of solution before returning; only works on integer weights.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> (CHECK_OPTIMUM === <span class="hljs-literal">undefined</span>) CHECK_OPTIMUM = <span class="hljs-literal">true</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compatibility</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> assert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">condition</span>) </span>{
		<span class="hljs-keyword">if</span> (!condition) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Assertion failed'</span>);
	};

	<span class="hljs-keyword">var</span> min = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, i, j</span>) </span>{

		<span class="hljs-keyword">var</span> o = a[i];

		<span class="hljs-keyword">while</span> (--j &gt; i) {
			<span class="hljs-keyword">if</span> (a[j] &lt; o) o = a[j];
		}

		<span class="hljs-keyword">return</span> o;
	};

	<span class="hljs-keyword">var</span> zip = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, fn</span>) </span>{
		<span class="hljs-keyword">var</span> shortest = a[<span class="hljs-number">0</span>].length &lt; a[<span class="hljs-number">1</span>].length ? a[<span class="hljs-number">0</span>] : a[<span class="hljs-number">1</span>];

		shortest.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, i</span>) </span>{
			<span class="hljs-keyword">if</span> (fn.apply(<span class="hljs-literal">null</span>, a.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>)</span>{ <span class="hljs-keyword">return</span> array[i]; }))) <span class="hljs-keyword">return</span>;
		});
	};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><end></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> maxWeightMatching = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">edges, maxcardinality</span>) </span>{
		<span class="hljs-keyword">var</span> i, j, k, p, w, len;

		<span class="hljs-keyword">if</span> (maxcardinality === <span class="hljs-literal">undefined</span>) maxcardinality = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute a maximum-weighted matching in the general undirected
weighted graph given by &quot;edges&quot;.  If &quot;maxcardinality&quot; is true,
only maximum-cardinality matchings are considered as solutions.</p>
<p>Edges is a sequence of tuples (i, j, wt) describing an undirected
edge between vertex i and vertex j with weight wt.  There is at most
one edge between any two vertices; no vertex has an edge to itthis.
Vertices are identified by consecutive, non-negative integers.</p>
<p>Return a list &quot;mate&quot;, such that mate[i] === j if vertex i is
matched to vertex j, and mate[i] === -1 if vertex i is not matched.</p>
<p>This function takes time O(n ** 3){</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Vertices are numbered 0 .. (nvertex-1).
Non-trivial blossoms are numbered nvertex .. (2*nvertex-1)</p>
<p>Edges are numbered 0 .. (nedge-1).
Edge endpoints are numbered 0 .. (2<em>nedge-1), such that endpoints
(2</em>k) and (2*k+1) both belong to edge k.</p>
<p>Many terms used in the comments (sub-blossom, T-vertex) come from
the paper by Galil; read the paper before reading this code.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Deal swiftly with empty graphs.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> (!edges.length) <span class="hljs-keyword">return</span> [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Count vertices + find the maximum edge weight.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> nedge = edges.length;
		<span class="hljs-keyword">var</span> nvertex = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">var</span> maxweight = <span class="hljs-number">0</span>;

		len = nedge;
		<span class="hljs-keyword">while</span> (len--) {
			i = edges[len][<span class="hljs-number">0</span>];
			j = edges[len][<span class="hljs-number">1</span>];
			w = edges[len][<span class="hljs-number">2</span>];

			assert(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i !== j);
			<span class="hljs-keyword">if</span> (i &gt;= nvertex) nvertex = i + <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (j &gt;= nvertex) nvertex = j + <span class="hljs-number">1</span>;

			maxweight = <span class="hljs-built_in">Math</span>.max(maxweight, w);
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If p is an edge endpoint,
endpoint[p] is the vertex to which endpoint p is attached.
Not modified by the algorithm.</p></div></div><div class="code"><div class="wrapper">		p = <span class="hljs-number">2</span> * nedge;
		<span class="hljs-keyword">var</span> endpoint = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(p);
		<span class="hljs-keyword">while</span> (p--) endpoint[p] = edges[<span class="hljs-built_in">Math</span>.floor(p / <span class="hljs-number">2</span>)][p % <span class="hljs-number">2</span>];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If v is a vertex,
neighbend[v] is the list of remote endpoints of the edges attached to v.
Not modified by the algorithm.</p></div></div><div class="code"><div class="wrapper">		i = nvertex;
		<span class="hljs-keyword">var</span> neighbend = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) neighbend[i] = [];

		<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; nedge; ++k) {
			i = edges[k][<span class="hljs-number">0</span>];
			j = edges[k][<span class="hljs-number">1</span>];
			neighbend[i].push(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>);
			neighbend[j].push(<span class="hljs-number">2</span> * k);
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If v is a vertex,
mate[v] is the remote endpoint of its matched edge, or -1 if it is single
(i.e. endpoint[mate[v]] is v&#39;s partner vertex).
Initially all vertices are single; updated during augmentation.</p></div></div><div class="code"><div class="wrapper">		i = nvertex;
		<span class="hljs-keyword">var</span> mate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) mate[i] = -<span class="hljs-number">1</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If b is a top-level blossom,
label[b] is 0 if b is unlabeled (free);
            1 if b is an S-vertex/blossom;
            2 if b is a T-vertex/blossom.
The label of a vertex is found by looking at the label of its
top-level containing blossom.
If v is a vertex inside a T-blossom,
label[v] is 2 iff v is reachable from an S-vertex outside the blossom.
Labels are assigned during a stage and reset after each augmentation.</p></div></div><div class="code"><div class="wrapper">		i = <span class="hljs-number">2</span> * nvertex;
		<span class="hljs-keyword">var</span> label = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) label[i] = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If b is a labeled top-level blossom,
labelend[b] is the remote endpoint of the edge through which b obtained
its label, or -1 if b&#39;s base vertex is single.
If v is a vertex inside a T-blossom and label[v] === 2,
labelend[v] is the remote endpoint of the edge through which v is
reachable from outside the blossom.</p></div></div><div class="code"><div class="wrapper">		i = <span class="hljs-number">2</span> * nvertex;
		<span class="hljs-keyword">var</span> labelend = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) labelend[i] = -<span class="hljs-number">1</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If v is a vertex,
inblossom[v] is the top-level blossom to which v belongs.
If v is a top-level vertex, v is itthis a blossom (a trivial blossom)
and inblossom[v] === v.
Initially all vertices are top-level trivial blossoms.</p></div></div><div class="code"><div class="wrapper">		i = nvertex;
		<span class="hljs-keyword">var</span> inblossom = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) inblossom[i] = i;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If b is a sub-blossom,
blossomparent[b] is its immediate parent (sub-)blossom.
If b is a top-level blossom, blossomparent[b] is -1.</p></div></div><div class="code"><div class="wrapper">		i = <span class="hljs-number">2</span> * nvertex;
		<span class="hljs-keyword">var</span> blossomparent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) blossomparent[i] = -<span class="hljs-number">1</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If b is a non-trivial (sub-)blossom,
blossomchilds[b] is an ordered list of its sub-blossoms, starting with
the base and going round the blossom.</p></div></div><div class="code"><div class="wrapper">		i = <span class="hljs-number">2</span> * nvertex;
		<span class="hljs-keyword">var</span> blossomchilds = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) blossomchilds[i] = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If b is a (sub-)blossom,
blossombase[b] is its base VERTEX (i.e. recursive sub-blossom).</p></div></div><div class="code"><div class="wrapper">		len = <span class="hljs-number">2</span> * nvertex;
		<span class="hljs-keyword">var</span> blossombase = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);
		<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; nvertex; ++i) blossombase[i] = i;
		<span class="hljs-keyword">for</span>(; i &lt; len; ++i) blossombase[i] = -<span class="hljs-number">1</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If b is a non-trivial (sub-)blossom,
blossomendps[b] is a list of endpoints on its connecting edges,
such that blossomendps[b][i] is the local endpoint of blossomchilds[b][i]
on the edge that connects it to blossomchilds[b][wrap(i+1)].</p></div></div><div class="code"><div class="wrapper">		i = <span class="hljs-number">2</span> * nvertex;
		<span class="hljs-keyword">var</span> blossomendps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) blossomendps[i] = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If v is a free vertex (or an unreached vertex inside a T-blossom),
bestedge[v] is the edge to an S-vertex with least slack,
or -1 if there is no such edge.
If b is a (possibly trivial) top-level S-blossom,
bestedge[b] is the least-slack edge to a different S-blossom,
or -1 if there is no such edge.
This is used for efficient computation of delta2 and delta3.</p></div></div><div class="code"><div class="wrapper">		i = <span class="hljs-number">2</span> * nvertex;
		<span class="hljs-keyword">var</span> bestedge = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) bestedge[i] = -<span class="hljs-number">1</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If b is a non-trivial top-level S-blossom,
blossombestedges[b] is a list of least-slack edges to neighbouring
S-blossoms, or null if no such list has been computed yet.
This is used for efficient computation of delta3.</p></div></div><div class="code"><div class="wrapper">		i = <span class="hljs-number">2</span> * nvertex;
		<span class="hljs-keyword">var</span> blossombestedges = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) blossombestedges[i] = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>List of currently unused blossom numbers.</p></div></div><div class="code"><div class="wrapper">		i = nvertex;
		<span class="hljs-keyword">var</span> unusedblossoms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) unusedblossoms[i] = nvertex + i;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If v is a vertex,
dualvar[v] = 2 * u(v) where u(v) is the v&#39;s variable in the dual
optimization problem (multiplication by two ensures integer values
throughout the algorithm if all edge weights are integers).
If b is a non-trivial blossom,
dualvar[b] = z(b) where z(b) is b&#39;s variable in the dual optimization
problem.</p></div></div><div class="code"><div class="wrapper">		len = <span class="hljs-number">2</span> * nvertex;
		<span class="hljs-keyword">var</span> dualvar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);
		<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; nvertex; ++i) dualvar[i] = maxweight;
		<span class="hljs-keyword">for</span>(; i &lt; len; ++i) dualvar[i] = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If allowedge[k] is true, edge k has zero slack in the optimization
problem; if allowedge[k] is false, the edge&#39;s slack may or may not
be zero.</p></div></div><div class="code"><div class="wrapper">		i = nedge;
		<span class="hljs-keyword">var</span> allowedge = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i);
		<span class="hljs-keyword">while</span> (i--) allowedge[i] = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Queue of newly discovered S-vertices.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> queue = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return 2 * slack of edge k (does not work inside blossoms).</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> slack = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k</span>) </span>{
			<span class="hljs-keyword">var</span> i = edges[k][<span class="hljs-number">0</span>];
			<span class="hljs-keyword">var</span> j = edges[k][<span class="hljs-number">1</span>];
			<span class="hljs-keyword">var</span> wt = edges[k][<span class="hljs-number">2</span>];
			<span class="hljs-keyword">return</span> dualvar[i] + dualvar[j] - <span class="hljs-number">2</span> * wt;
		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Generate the leaf vertices of a blossom.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> blossomLeaves = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">b, fn</span>) </span>{
			<span class="hljs-keyword">if</span> (b &lt; nvertex){
				<span class="hljs-keyword">if</span>(fn(b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">var</span> len, i, t;
				len = blossomchilds[b].length;
				<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; ++i){
					t = blossomchilds[b][i];
					<span class="hljs-keyword">if</span> (t &lt; nvertex) {
						<span class="hljs-keyword">if</span> (fn(t)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
					}
					<span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">if</span> (blossomLeaves(t, fn)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
					}
				}
			}
		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Assign label t to the top-level blossom containing vertex w
and record the fact that w was reached through the edge with
remote endpoint p.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> assignLabel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">w, t, p</span>) </span>{
			<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'assignLabel('</span> + w + <span class="hljs-string">','</span> + t + <span class="hljs-string">','</span> + p + <span class="hljs-string">')'</span>);
			<span class="hljs-keyword">var</span> b = inblossom[w], e;
			assert(label[w] === <span class="hljs-number">0</span> &amp;&amp; label[b] === <span class="hljs-number">0</span>);
			label[w] = label[b] = t;
			labelend[w] = labelend[b] = p;
			bestedge[w] = bestedge[b] = -<span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (t === <span class="hljs-number">1</span>){</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>b became an S-vertex/blossom; add it(s vertices) to the queue.</p></div></div><div class="code"><div class="wrapper">				blossomLeaves(b, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{ queue.push(e); });
				<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'PUSH '</span> + queue);
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t === <span class="hljs-number">2</span>){</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>b became a T-vertex/blossom; assign label S to its mate.
(If b is a non-trivial blossom, its base is the only vertex
with an external mate.)</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">var</span> base = blossombase[b];
				assert(mate[base] &gt;= <span class="hljs-number">0</span>);
				assignLabel(endpoint[mate[base]], <span class="hljs-number">1</span>, mate[base] ^ <span class="hljs-number">1</span>);
			}

		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trace back from vertices v and w to discover either a new blossom
or an augmenting path. Return the base vertex of the new blossom or -1.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> scanBlossom = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v, w</span>) </span>{
			<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'scanBlossom('</span> + v + <span class="hljs-string">','</span> + w + <span class="hljs-string">')'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trace back from v and w, placing breadcrumbs as we go.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> b, tmp, i;
			<span class="hljs-keyword">var</span> path = [];
			<span class="hljs-keyword">var</span> base = -<span class="hljs-number">1</span>;
			<span class="hljs-keyword">while</span> (v !== -<span class="hljs-number">1</span> || w !== -<span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Look for a breadcrumb in v&#39;s blossom or put a new breadcrumb.</p></div></div><div class="code"><div class="wrapper">				b = inblossom[v];
				<span class="hljs-keyword">if</span> (label[b] &amp; <span class="hljs-number">4</span>) {
					base = blossombase[b];
					<span class="hljs-keyword">break</span>;
				}
				assert(label[b] === <span class="hljs-number">1</span>);
				path.push(b);
				label[b] = <span class="hljs-number">5</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trace one step back.</p></div></div><div class="code"><div class="wrapper">				assert(labelend[b] === mate[blossombase[b]]);
				<span class="hljs-keyword">if</span> (labelend[b] === -<span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The base of blossom b is single; stop tracing this path.</p></div></div><div class="code"><div class="wrapper">					v = -<span class="hljs-number">1</span>;
				}
				<span class="hljs-keyword">else</span> {
					v = endpoint[labelend[b]];
					b = inblossom[v];
					assert(label[b] === <span class="hljs-number">2</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>b is a T-blossom; trace one more step back.</p></div></div><div class="code"><div class="wrapper">					assert(labelend[b] &gt;= <span class="hljs-number">0</span>);
					v = endpoint[labelend[b]];
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Swap v and w so that we alternate between both paths.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> (w !== -<span class="hljs-number">1</span>) {
					tmp = v;
					v = w;
					w = tmp;
				}
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove breadcrumbs.</p></div></div><div class="code"><div class="wrapper">			i = path.length;
			<span class="hljs-keyword">while</span> (i--) {
				b = path[i];
				label[b] = <span class="hljs-number">1</span>;
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return base vertex, if we found one.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> base;
		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Construct a new blossom with given base, containing edge k which
connects a pair of S vertices. Label the new blossom as S; set its dual
variable to zero; relabel its T-vertices to S and add them to the queue.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> addBlossom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">base, k</span>) </span>{
			<span class="hljs-keyword">var</span> i, j, len, tmp, x, y, z, m, n, nblist, nblists, bestedgeto;
			<span class="hljs-keyword">var</span> v = edges[k][<span class="hljs-number">0</span>];
			<span class="hljs-keyword">var</span> w = edges[k][<span class="hljs-number">1</span>];
			<span class="hljs-keyword">var</span> wt = edges[k][<span class="hljs-number">2</span>];
			<span class="hljs-keyword">var</span> bb = inblossom[base];
			<span class="hljs-keyword">var</span> bv = inblossom[v];
			<span class="hljs-keyword">var</span> bw = inblossom[w];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create blossom.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> b = unusedblossoms.pop();
			<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'addBlossom('</span> + base + <span class="hljs-string">','</span> + k + <span class="hljs-string">') (v='</span> + v + <span class="hljs-string">' w='</span> + w + <span class="hljs-string">') -&gt; '</span> + b);
			blossombase[b] = base;
			blossomparent[b] = -<span class="hljs-number">1</span>;
			blossomparent[bb] = b;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make list of sub-blossoms and their interconnecting edge endpoints.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> path = blossomchilds[b] = [];
			<span class="hljs-keyword">var</span> endps = blossomendps[b] = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trace back from v to base.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">while</span> (bv !== bb) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add bv to the new blossom.</p></div></div><div class="code"><div class="wrapper">				blossomparent[bv] = b;
				path.push(bv);
				endps.push(labelend[bv]);
				assert((label[bv] === <span class="hljs-number">2</span> || (label[bv] === <span class="hljs-number">1</span> &amp;&amp; labelend[bv] === mate[blossombase[bv]])));</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trace one step back.</p></div></div><div class="code"><div class="wrapper">				assert(labelend[bv] &gt;= <span class="hljs-number">0</span>);
				v = endpoint[labelend[bv]];
				bv = inblossom[v];
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reverse lists, add endpoint that connects the pair of S vertices.</p></div></div><div class="code"><div class="wrapper">			path.push(bb);
			path.reverse();
			endps.reverse();
			endps.push(<span class="hljs-number">2</span>*k);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trace back from w to base.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">while</span> (bw !== bb) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add bw to the new blossom.</p></div></div><div class="code"><div class="wrapper">				blossomparent[bw] = b;
				path.push(bw);
				endps.push(labelend[bw] ^ <span class="hljs-number">1</span>);
				assert((label[bw] === <span class="hljs-number">2</span> || (label[bw] === <span class="hljs-number">1</span> &amp;&amp; labelend[bw] === mate[blossombase[bw]])));</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trace one step back.</p></div></div><div class="code"><div class="wrapper">				assert(labelend[bw] &gt;= <span class="hljs-number">0</span>);
				w = endpoint[labelend[bw]];
				bw = inblossom[w];
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set label to S.</p></div></div><div class="code"><div class="wrapper">			assert(label[bb] === <span class="hljs-number">1</span>);
			label[b] = <span class="hljs-number">1</span>;
			labelend[b] = labelend[bb];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set dual variable to zero.</p></div></div><div class="code"><div class="wrapper">			dualvar[b] = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Relabel vertices.</p></div></div><div class="code"><div class="wrapper">			blossomLeaves(b, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
				<span class="hljs-keyword">if</span> (label[inblossom[v]] === <span class="hljs-number">2</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This T-vertex now turns into an S-vertex because it becomes
part of an S-blossom; add it to the queue.</p></div></div><div class="code"><div class="wrapper">					queue.push(v);
				}
				inblossom[v] = b;
			});</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute blossombestedges[b].</p></div></div><div class="code"><div class="wrapper">			z = <span class="hljs-number">2</span> * nvertex;
			bestedgeto = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(z);
			<span class="hljs-keyword">while</span> (z--) bestedgeto[z] = -<span class="hljs-number">1</span>;

			len = path.length;
			<span class="hljs-keyword">for</span> (z = <span class="hljs-number">0</span>; z &lt; len; ++z) {
				bv = path[z];

				<span class="hljs-keyword">if</span> (blossombestedges[bv] === <span class="hljs-literal">null</span>){</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This subblossom does not have a list of least-slack edges;
get the information from the vertices.</p></div></div><div class="code"><div class="wrapper">					nblists = [];
					blossomLeaves(bv, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)</span>{
						j = neighbend[v].length;
						tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(j);
						<span class="hljs-keyword">while</span> (j--) {
							<span class="hljs-keyword">var</span> p = neighbend[v][j];
							tmp[j] = <span class="hljs-built_in">Math</span>.floor(p/<span class="hljs-number">2</span>);
						}
						nblists.push(tmp);
					});
				}
				<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Walk this subblossom&#39;s least-slack edges.</p></div></div><div class="code"><div class="wrapper">					nblists = [ blossombestedges[bv] ];
				}

				<span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>, m = nblists.length; x &lt; m; ++x) {
					nblist = nblists[x];

					<span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>, n = nblist.length; y &lt; n; ++y) {
						k = nblist[y];

						i = edges[k][<span class="hljs-number">0</span>];
						j = edges[k][<span class="hljs-number">1</span>];
						wt = edges[k][<span class="hljs-number">2</span>];

						<span class="hljs-keyword">if</span> (inblossom[j] === b) {
							tmp = i;
							i = j;
							j = tmp;
						}

						<span class="hljs-keyword">var</span> bj = inblossom[j];

						<span class="hljs-keyword">if</span> (bj !== b &amp;&amp; label[bj] === <span class="hljs-number">1</span> &amp;&amp;
							(bestedgeto[bj] === -<span class="hljs-number">1</span> || slack(k) &lt; slack(bestedgeto[bj]))) {
							bestedgeto[bj] = k;
						}
					}
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Forget about least-slack edges of the subblossom.</p></div></div><div class="code"><div class="wrapper">				blossombestedges[bv] = <span class="hljs-literal">null</span>;
				bestedge[bv] = -<span class="hljs-number">1</span>;
			}


			blossombestedges[b] = [];
			len = bestedgeto.length;
			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; ++i) {
				k = bestedgeto[i];
				<span class="hljs-keyword">if</span> (k !== -<span class="hljs-number">1</span>) blossombestedges[b].push(k);
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Select bestedge[b].</p></div></div><div class="code"><div class="wrapper">			len = blossombestedges[b].length;
			<span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {
				bestedge[b] = blossombestedges[b][<span class="hljs-number">0</span>];
				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; len; ++i) {
					k = blossombestedges[b][i];
					<span class="hljs-keyword">if</span> (slack(k) &lt; slack(bestedge[b])) {
						bestedge[b] = k;
					}
				}
			}
			<span class="hljs-keyword">else</span> bestedge[b] = -<span class="hljs-number">1</span>;

			<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'blossomchilds['</span> + b + <span class="hljs-string">']='</span> + blossomchilds[b]);
		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Expand the given top-level blossom.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> expandBlossom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b, endstage</span>) </span>{
			<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'expandBlossom('</span> + b + <span class="hljs-string">','</span> + endstage + <span class="hljs-string">') '</span> + blossomchilds[b]);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert sub-blossoms into top-level blossoms.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> i, j, len, s, p, entrychild, jstep, endptrick, bv, stop, base;

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; blossomchilds[b].length; ++i) {
				s = blossomchilds[b][i];

				blossomparent[s] = -<span class="hljs-number">1</span>;
				<span class="hljs-keyword">if</span> (s &lt; nvertex) inblossom[s] = s;
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (endstage &amp;&amp; dualvar[s] === <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Recursively expand this sub-blossom.</p></div></div><div class="code"><div class="wrapper">					expandBlossom(s, endstage);
				}
				<span class="hljs-keyword">else</span> {
					blossomLeaves(s, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
						inblossom[v] = s;
					});
				}
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we expand a T-blossom during a stage, its sub-blossoms must be
relabeled.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> (!endstage &amp;&amp; label[b] === <span class="hljs-number">2</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Start at the sub-blossom through which the expanding
blossom obtained its label, and relabel sub-blossoms untili
we reach the base.
Figure out through which sub-blossom the expanding blossom
obtained its label initially.</p></div></div><div class="code"><div class="wrapper">				assert(labelend[b] &gt;= <span class="hljs-number">0</span>);
				entrychild = inblossom[endpoint[labelend[b] ^ <span class="hljs-number">1</span>]];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Decide in which direction we will go round the blossom.</p></div></div><div class="code"><div class="wrapper">				j = blossomchilds[b].indexOf(entrychild);
				<span class="hljs-keyword">if</span> (j &amp; <span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Start index is odd; go forward.</p></div></div><div class="code"><div class="wrapper">					jstep = <span class="hljs-number">1</span>;
					endptrick = <span class="hljs-number">0</span>;
					stop = blossomchilds[b].length;
					base = <span class="hljs-number">0</span>;
				}
				<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Start index is even; go backward.</p></div></div><div class="code"><div class="wrapper">					jstep = -<span class="hljs-number">1</span>;
					endptrick = <span class="hljs-number">1</span>;
					stop = <span class="hljs-number">0</span>;
					base = blossomchilds[b].length;
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Move along the blossom until we get to the base.</p></div></div><div class="code"><div class="wrapper">				p = labelend[b];
				<span class="hljs-keyword">while</span> (j !== stop) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Relabel the T-sub-blossom.</p></div></div><div class="code"><div class="wrapper">					label[endpoint[p ^ <span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;
					label[endpoint[blossomendps[b][j-endptrick]^endptrick^<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;
					assignLabel(endpoint[p ^ <span class="hljs-number">1</span>], <span class="hljs-number">2</span>, p);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Step to the next S-sub-blossom and note its forward endpoint.</p></div></div><div class="code"><div class="wrapper">					allowedge[<span class="hljs-built_in">Math</span>.floor(blossomendps[b][j-endptrick]/<span class="hljs-number">2</span>)] = <span class="hljs-literal">true</span>;
					j += jstep;
					p = blossomendps[b][j-endptrick] ^ endptrick;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Step to the next T-sub-blossom.</p></div></div><div class="code"><div class="wrapper">					allowedge[<span class="hljs-built_in">Math</span>.floor(p/<span class="hljs-number">2</span>)] = <span class="hljs-literal">true</span>;
					j += jstep;
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Relabel the base T-sub-blossom WITHOUT stepping through to
its mate (so don&#39;t call assignLabel).</p></div></div><div class="code"><div class="wrapper">				bv = blossomchilds[b][<span class="hljs-number">0</span>];
				label[endpoint[p ^ <span class="hljs-number">1</span>]] = label[bv] = <span class="hljs-number">2</span>;
				labelend[endpoint[p ^ <span class="hljs-number">1</span>]] = labelend[bv] = p;
				bestedge[bv] = -<span class="hljs-number">1</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Continue along the blossom until we get back to entrychild.</p></div></div><div class="code"><div class="wrapper">				j = base + jstep;
				<span class="hljs-keyword">while</span> (blossomchilds[b][j] !== entrychild) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Examine the vertices of the sub-blossom to see whether
it is reachable from a neighbouring S-vertex outside the
expanding blossom.</p></div></div><div class="code"><div class="wrapper">					bv = blossomchilds[b][j];
					<span class="hljs-keyword">if</span> (label[bv] === <span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This sub-blossom just got label S through one of its
neighbours; leave it.</p></div></div><div class="code"><div class="wrapper">						j += jstep;
						<span class="hljs-keyword">continue</span>;
					}
					blossomLeaves(bv, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)</span>{
						<span class="hljs-keyword">if</span> (label[v] !== <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the sub-blossom contains a reachable vertex, assign
label T to the sub-blossom.</p></div></div><div class="code"><div class="wrapper">							assert(label[v] === <span class="hljs-number">2</span>);
							assert(inblossom[v] === bv);
							label[v] = <span class="hljs-number">0</span>;
							label[endpoint[mate[blossombase[bv]]]] = <span class="hljs-number">0</span>;
							assignLabel(v, <span class="hljs-number">2</span>, labelend[v]);
							<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
						}
					});

					j += jstep;
				}
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Recycle the blossom number.</p></div></div><div class="code"><div class="wrapper">			label[b] = labelend[b] = -<span class="hljs-number">1</span>;
			blossomchilds[b] = blossomendps[b] = <span class="hljs-literal">null</span>;
			blossombase[b] = -<span class="hljs-number">1</span>;
			blossombestedges[b] = <span class="hljs-literal">null</span>;
			bestedge[b] = -<span class="hljs-number">1</span>;
			unusedblossoms.push(b);
		};

		<span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, n</span>) </span>{
			<span class="hljs-keyword">var</span> head = a.splice(<span class="hljs-number">0</span>, n);
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
				a.push(head[i]);
			}
		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Swap matched/unmatched edges over an alternating path through blossom b
between vertex v and the base vertex. Keep blossom bookkeeping consistent.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> augmentBlossom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b, v</span>)</span>{
			<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'augmentBlossom('</span> + b + <span class="hljs-string">','</span> + v + <span class="hljs-string">')'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Bubble up through the blossom tree from vertex v to an immediate
sub-blossom of b.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> i, j, t, jstep, endptrick, stop, len, p;
			t = v;
			<span class="hljs-keyword">while</span> (blossomparent[t] !== b)
				t = blossomparent[t];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Recursively deal with the first sub-blossom.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> (t &gt;= nvertex)
				augmentBlossom(t, v);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Decide in which direction we will go round the blossom.</p></div></div><div class="code"><div class="wrapper">			i = j = blossomchilds[b].indexOf(t);
			len = blossomchilds[b].length;
			<span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Start index is odd; go forward.</p></div></div><div class="code"><div class="wrapper">				jstep = <span class="hljs-number">1</span>;
				endptrick = <span class="hljs-number">0</span>;
				stop = len;
			}
			<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Start index is even; go backward.</p></div></div><div class="code"><div class="wrapper">				jstep = -<span class="hljs-number">1</span>;
				endptrick = <span class="hljs-number">1</span>;
				stop = <span class="hljs-number">0</span>;
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Move along the blossom until we get to the base.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">while</span> (j !== stop) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Step to the next sub-blossom and augment it recursively.</p></div></div><div class="code"><div class="wrapper">				j += jstep;
				t = blossomchilds[b][j];
				p = blossomendps[b][j-endptrick] ^ endptrick;
				<span class="hljs-keyword">if</span> (t &gt;= nvertex)
					augmentBlossom(t, endpoint[p]);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Step to the next sub-blossom and augment it recursively.</p></div></div><div class="code"><div class="wrapper">				j += jstep;
				t = blossomchilds[b][<span class="hljs-built_in">Math</span>.abs(j % len)];
				<span class="hljs-keyword">if</span> (t &gt;= nvertex)
					augmentBlossom(t, endpoint[p ^ <span class="hljs-number">1</span>]);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Match the edge connecting those sub-blossoms.</p></div></div><div class="code"><div class="wrapper">				mate[endpoint[p]] = p ^ <span class="hljs-number">1</span>;
				mate[endpoint[p ^ <span class="hljs-number">1</span>]] = p;
				<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'PAIR '</span> + endpoint[p] + <span class="hljs-string">' '</span> + endpoint[p^<span class="hljs-number">1</span>] + <span class="hljs-string">' (k='</span> + <span class="hljs-built_in">Math</span>.floor(p/<span class="hljs-number">2</span>) + <span class="hljs-string">')'</span>);
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Rotate the list of sub-blossoms to put the new base at the front.</p></div></div><div class="code"><div class="wrapper">			rotate(blossomchilds[b], i);
			rotate(blossomendps[b], i);
			blossombase[b] = blossombase[blossomchilds[b][<span class="hljs-number">0</span>]];
			assert(blossombase[b] === v);
		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Swap matched/unmatched edges over an alternating path between two
single vertices. The augmenting path runs through edge k, which
connects a pair of S vertices.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> augmentMatching = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k</span>) </span>{

			<span class="hljs-keyword">var</span> bs, t, bt, j;

			<span class="hljs-keyword">var</span> v = edges[k][<span class="hljs-number">0</span>];
			<span class="hljs-keyword">var</span> w = edges[k][<span class="hljs-number">1</span>];
			<span class="hljs-keyword">var</span> wt = edges[k][<span class="hljs-number">2</span>];

			<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'augmentMatching('</span> + k + <span class="hljs-string">') (v='</span> + v + <span class="hljs-string">' w='</span> + w + <span class="hljs-string">')'</span>);
			<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'PAIR '</span> + v + <span class="hljs-string">' '</span> + w + <span class="hljs-string">' (k='</span> + k + <span class="hljs-string">')'</span>);

			[[v, <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>], [w, <span class="hljs-number">2</span> * k]].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{
				<span class="hljs-keyword">var</span> s = e[<span class="hljs-number">0</span>];
				<span class="hljs-keyword">var</span> p = e[<span class="hljs-number">1</span>];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Match vertex s to remote endpoint p. Then trace back from s
until we find a single vertex, swapping matched and unmatched
edges as we go.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
					bs = inblossom[s];
					assert(label[bs] === <span class="hljs-number">1</span>);
					assert(labelend[bs] === mate[blossombase[bs]]);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Augment through the S-blossom from s to base.</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> (bs &gt;= nvertex)
						augmentBlossom(bs, s);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update mate[s]</p></div></div><div class="code"><div class="wrapper">					mate[s] = p;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trace one step back.</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> (labelend[bs] === -<span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reached single vertex; stop.</p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">break</span>;
					}
					t = endpoint[labelend[bs]];
					bt = inblossom[t];
					assert(label[bt] === <span class="hljs-number">2</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trace one step back.</p></div></div><div class="code"><div class="wrapper">					assert(labelend[bt] &gt;= <span class="hljs-number">0</span>);
					s = endpoint[labelend[bt]];
					j = endpoint[labelend[bt] ^ <span class="hljs-number">1</span>];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Augment through the T-blossom from j to base.</p></div></div><div class="code"><div class="wrapper">					assert(blossombase[bt] === t);
					<span class="hljs-keyword">if</span> (bt &gt;= nvertex)
						augmentBlossom(bt, j);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update mate[j]</p></div></div><div class="code"><div class="wrapper">					mate[j] = labelend[bt];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Keep the opposite endpoint;
it will be assigned to mate[s] in the next step.</p></div></div><div class="code"><div class="wrapper">					p = labelend[bt] ^ <span class="hljs-number">1</span>;
					<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'PAIR '</span> + s + <span class="hljs-string">' '</span> + t + <span class="hljs-string">' (k='</span> + <span class="hljs-built_in">Math</span>.floor(p/<span class="hljs-number">2</span>) + <span class="hljs-string">')'</span>);
				}
			});
		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Verify that the optimum solution has been reached.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> verifyOptimum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> i, j, wt, v, b, p, k, s, vdualoffset, iblossoms, jblossoms;
			<span class="hljs-keyword">if</span> (maxcardinality) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Vertices may have negative dual;
find a constant non-negative number to add to all vertex duals.</p></div></div><div class="code"><div class="wrapper">				vdualoffset = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, -min(dualvar, <span class="hljs-number">0</span>, nvertex));
			}
			<span class="hljs-keyword">else</span> vdualoffset = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>all dual variables are non-negative</li>
</ol></div></div><div class="code"><div class="wrapper">			assert(min(dualvar, <span class="hljs-number">0</span>, nvertex) + vdualoffset &gt;= <span class="hljs-number">0</span>);
			assert(min(dualvar, nvertex, <span class="hljs-number">2</span> * nvertex) &gt;= <span class="hljs-number">0</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>all edges have non-negative slack and</li>
<li>all matched edges have zero slack;</li>
</ol></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; nedge; ++k) {
				i = edges[k][<span class="hljs-number">0</span>];
				j = edges[k][<span class="hljs-number">1</span>];
				wt = edges[k][<span class="hljs-number">2</span>];

				s = dualvar[i] + dualvar[j] - <span class="hljs-number">2</span> * wt;
				iblossoms = [i];
				jblossoms = [j];
				<span class="hljs-keyword">while</span> (blossomparent[iblossoms[iblossoms.length - <span class="hljs-number">1</span>]] !== -<span class="hljs-number">1</span>)
					iblossoms.push(blossomparent[iblossoms[iblossoms.length - <span class="hljs-number">1</span>]]);
				<span class="hljs-keyword">while</span> (blossomparent[jblossoms[jblossoms.length - <span class="hljs-number">1</span>]] !== -<span class="hljs-number">1</span>)
					jblossoms.push(blossomparent[jblossoms[jblossoms.length - <span class="hljs-number">1</span>]]);
				iblossoms.reverse();
				jblossoms.reverse();
				zip([iblossoms, jblossoms], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bi, bj</span>)</span>{
					<span class="hljs-keyword">if</span> (bi !== bj) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
					s += <span class="hljs-number">2</span> * dualvar[bi];
				});
				assert(s &gt;= <span class="hljs-number">0</span>);
				<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.floor(mate[i] / <span class="hljs-number">2</span>) === k || <span class="hljs-built_in">Math</span>.floor(mate[j] / <span class="hljs-number">2</span>) === k) {
					assert(<span class="hljs-built_in">Math</span>.floor(mate[i] / <span class="hljs-number">2</span>) === k &amp;&amp; <span class="hljs-built_in">Math</span>.floor(mate[j] / <span class="hljs-number">2</span>) === k);
					assert(s === <span class="hljs-number">0</span>);
				}
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>all single vertices have zero dual value;</li>
</ol></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> (v = <span class="hljs-number">0</span>; v &lt; nvertex; ++v)
				assert(mate[v] &gt;= <span class="hljs-number">0</span> || dualvar[v] + vdualoffset === <span class="hljs-number">0</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>all blossoms with positive dual value are full.</li>
</ol></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> (b = nvertex; b &lt; <span class="hljs-number">2</span> * nvertex; ++b) {
				<span class="hljs-keyword">if</span> (blossombase[b] &gt;= <span class="hljs-number">0</span> &amp;&amp; dualvar[b] &gt; <span class="hljs-number">0</span>) {
					assert(blossomendps[b].length % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>);
					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; blossomendps[b].length; i += <span class="hljs-number">2</span>) {
						p = blossomendps[b][i];
						assert(mate[endpoint[p]] === p ^ <span class="hljs-number">1</span>);
						assert(mate[endpoint[p ^ <span class="hljs-number">1</span>]] === p);
					}
				}
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ok.</p></div></div><div class="code"><div class="wrapper">		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check optimized delta2 against a trivial computation.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> checkDelta2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> v = <span class="hljs-number">0</span>; v &lt; nvertex; ++v) {
				<span class="hljs-keyword">if</span> (label[inblossom[v]] === <span class="hljs-number">0</span>) {
					<span class="hljs-keyword">var</span> bd = <span class="hljs-literal">null</span>;
					<span class="hljs-keyword">var</span> bk = -<span class="hljs-number">1</span>;
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; neighbend[v].length; ++i) {
						<span class="hljs-keyword">var</span> p = neighbend[v][i];
						<span class="hljs-keyword">var</span> k = <span class="hljs-built_in">Math</span>.floor(p / <span class="hljs-number">2</span>);
						<span class="hljs-keyword">var</span> w = endpoint[p];
						<span class="hljs-keyword">if</span> (label[inblossom[w]] === <span class="hljs-number">1</span>) {
							<span class="hljs-keyword">var</span> d = slack(k);
							<span class="hljs-keyword">if</span> (bk === -<span class="hljs-number">1</span> || d &lt; bd) {
								bk = k;
								bd = d;
							}
						}
					}
					<span class="hljs-keyword">if</span> (DEBUG &amp;&amp; (bestedge[v] !== -<span class="hljs-number">1</span> || bk !== -<span class="hljs-number">1</span>) &amp;&amp;
						(bestedge[v] === -<span class="hljs-number">1</span> || bd !== slack(bestedge[v]))) {
						DEBUG(
							<span class="hljs-string">'v='</span> + v +
							<span class="hljs-string">' bk='</span> + bk +
							<span class="hljs-string">' bd='</span> + bd +
							<span class="hljs-string">' bestedge='</span> + bestedge[v] +
							<span class="hljs-string">' slack='</span> + slack(bestedge[v])
						);
					}
					assert((bk === -<span class="hljs-number">1</span> &amp;&amp; bestedge[v] === -<span class="hljs-number">1</span>) || (bestedge[v] !== -<span class="hljs-number">1</span> &amp;&amp; bd === slack(bestedge[v])));
				}
			}
		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check optimized delta3 against a trivial computation.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> checkDelta3 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> bk = -<span class="hljs-number">1</span>;
			<span class="hljs-keyword">var</span> bd = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">var</span> tbk = -<span class="hljs-number">1</span>;
			<span class="hljs-keyword">var</span> tbd = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> b = <span class="hljs-number">0</span>; b &lt; <span class="hljs-number">2</span> * nvertex; ++b) {
				<span class="hljs-keyword">if</span> (blossomparent[b] === -<span class="hljs-number">1</span> &amp;&amp; label[b] === <span class="hljs-number">1</span>) {
					blossomLeaves(b, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)</span>{

						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>; x &lt; neighbend[v].length; ++x) {
							<span class="hljs-keyword">var</span> p = neighbend[v][x];
							<span class="hljs-keyword">var</span> k = <span class="hljs-built_in">Math</span>.floor(p / <span class="hljs-number">2</span>);
							<span class="hljs-keyword">var</span> w = endpoint[p];
							<span class="hljs-keyword">if</span> (inblossom[w] !== b &amp;&amp; label[inblossom[w]] === <span class="hljs-number">1</span>) {
								<span class="hljs-keyword">var</span> d = slack(k);
								<span class="hljs-keyword">if</span> (bk === -<span class="hljs-number">1</span> || d &lt; bd) {
									bk = k;
									bd = d;
								}
							}
						}

					});

					<span class="hljs-keyword">if</span> (bestedge[b] !== -<span class="hljs-number">1</span>) {
						<span class="hljs-keyword">var</span> i = edges[bestedge[b]][<span class="hljs-number">0</span>];
						<span class="hljs-keyword">var</span> j = edges[bestedge[b]][<span class="hljs-number">1</span>];
						<span class="hljs-keyword">var</span> wt = edges[bestedge[b]][<span class="hljs-number">2</span>];

						assert(inblossom[i] === b || inblossom[j] === b);
						assert(inblossom[i] !== b || inblossom[j] !== b);
						assert(label[inblossom[i]] === <span class="hljs-number">1</span> &amp;&amp; label[inblossom[j]] === <span class="hljs-number">1</span>);
						<span class="hljs-keyword">if</span> (tbk === -<span class="hljs-number">1</span> || slack(bestedge[b]) &lt; tbd) {
							tbk = bestedge[b];
							tbd = slack(bestedge[b]);
						}
					}
				}
			}
			<span class="hljs-keyword">if</span> (DEBUG &amp;&amp; bd !== tbd)
				DEBUG(<span class="hljs-string">'bk='</span> + bk + <span class="hljs-string">' tbk='</span> + tbk + <span class="hljs-string">' bd='</span> + bd + <span class="hljs-string">' tbd='</span> + tbd);
			assert(bd === tbd);
		};

		<span class="hljs-keyword">var</span> b, d, t, v, augmented, kslack, base, deltatype, delta, deltaedge, deltablossom, wt, tmp;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Main loop: continue until no further improvement is possible.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> (t = <span class="hljs-number">0</span>; t &lt; nvertex; ++t) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Each iteration of this loop is a &quot;stage&quot;.
A stage finds an augmenting path and uses that to improve
the matching.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'STAGE '</span> + t);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove labels from top-level blossoms/vertices.</p></div></div><div class="code"><div class="wrapper">			i = <span class="hljs-number">2</span> * nvertex;
			<span class="hljs-keyword">while</span> (i--) label[i] = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Forget all about least-slack edges.</p></div></div><div class="code"><div class="wrapper">			i = <span class="hljs-number">2</span> * nvertex;
			<span class="hljs-keyword">while</span> (i--) bestedge[i] = -<span class="hljs-number">1</span>;
			i = nvertex;
			<span class="hljs-keyword">while</span> (i--) blossombestedges[nvertex + i] = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Loss of labeling means that we can not be sure that currently
allowable edges remain allowable througout this stage.</p></div></div><div class="code"><div class="wrapper">			i = nedge;
			<span class="hljs-keyword">while</span> (i--) allowedge[i] = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make queue empty.</p></div></div><div class="code"><div class="wrapper">			queue = [];
	 </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Label single blossoms/vertices with S and put them in the queue.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> (v = <span class="hljs-number">0</span>; v &lt; nvertex; ++v) {
				<span class="hljs-keyword">if</span> (mate[v] === -<span class="hljs-number">1</span> &amp;&amp; label[inblossom[v]] === <span class="hljs-number">0</span>)
					assignLabel(v, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Loop until we succeed in augmenting the matching.</p></div></div><div class="code"><div class="wrapper">			augmented = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Each iteration of this loop is a &quot;substage&quot;.
A substage tries to find an augmenting path;
if found, the path is used to improve the matching and
the stage ends. If there is no augmenting path, the
primal-dual method is used to pump some slack out of
the dual variables.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'SUBSTAGE'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Continue labeling until all vertices which are reachable
through an alternating path have got a label.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">while</span> (queue.length &amp;&amp; !augmented) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take an S vertex from the queue.</p></div></div><div class="code"><div class="wrapper">					v = queue.pop();
					<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'POP v='</span> + v);
					assert(label[inblossom[v]] === <span class="hljs-number">1</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Scan its neighbours:</p></div></div><div class="code"><div class="wrapper">					len = neighbend[v].length;
					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; ++i) {
						p = neighbend[v][i];
						k = <span class="hljs-built_in">Math</span>.floor(p / <span class="hljs-number">2</span>);
						w = endpoint[p];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>w is a neighbour to v</p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">if</span> (inblossom[v] === inblossom[w]) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>this edge is internal to a blossom; ignore it</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">continue</span>;
						}
						<span class="hljs-keyword">if</span> (!allowedge[k]) {
							kslack = slack(k);
							<span class="hljs-keyword">if</span> (kslack &lt;= <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>edge k has zero slack =&gt; it is allowable</p></div></div><div class="code"><div class="wrapper">								allowedge[k] = <span class="hljs-literal">true</span>;
							}
						}
						<span class="hljs-keyword">if</span> (allowedge[k]) {
							<span class="hljs-keyword">if</span> (label[inblossom[w]] === <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>(C1) w is a free vertex;
label w with T and label its mate with S (R12).</p></div></div><div class="code"><div class="wrapper">								assignLabel(w, <span class="hljs-number">2</span>, p ^ <span class="hljs-number">1</span>);
							}
							<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label[inblossom[w]] === <span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>(C2) w is an S-vertex (not in the same blossom);
follow back-links to discover either an
augmenting path or a new blossom.</p></div></div><div class="code"><div class="wrapper">								base = scanBlossom(v, w);
								<span class="hljs-keyword">if</span> (base &gt;= <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Found a new blossom; add it to the blossom
bookkeeping and turn it into an S-blossom.</p></div></div><div class="code"><div class="wrapper">									addBlossom(base, k);
								}
								<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Found an augmenting path; augment the
matching and end this stage.</p></div></div><div class="code"><div class="wrapper">									augmentMatching(k);
									augmented = <span class="hljs-number">1</span>;
									<span class="hljs-keyword">break</span>;
								}
							}
							<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label[w] === <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>w is inside a T-blossom, but w itthis has not
yet been reached from outside the blossom;
mark it as reached (we need this to relabel
during T-blossom expansion).</p></div></div><div class="code"><div class="wrapper">								assert(label[inblossom[w]] === <span class="hljs-number">2</span>);
								label[w] = <span class="hljs-number">2</span>;
								labelend[w] = p ^ <span class="hljs-number">1</span>;
							}
						}
						<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label[inblossom[w]] === <span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>keep track of the least-slack non-allowable edge to
a different S-blossom.</p></div></div><div class="code"><div class="wrapper">							b = inblossom[v];
							<span class="hljs-keyword">if</span> (bestedge[b] === -<span class="hljs-number">1</span> || kslack &lt; slack(bestedge[b]))
								bestedge[b] = k;
						}
						<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label[w] === <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>w is a free vertex (or an unreached vertex inside
a T-blossom) but we can not reach it yet;
keep track of the least-slack edge that reaches w.</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">if</span> (bestedge[w] === -<span class="hljs-number">1</span> || kslack &lt; slack(bestedge[w]))
								bestedge[w] = k;
						}
					}
				}

				<span class="hljs-keyword">if</span> (augmented) <span class="hljs-keyword">break</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>There is no augmenting path under these constraints;
compute delta and reduce slack in the optimization problem.
(Note that our vertex dual variables, edge slacks and delta&#39;s
are pre-multiplied by two.)</p></div></div><div class="code"><div class="wrapper">				deltatype = -<span class="hljs-number">1</span>;
				delta = deltaedge = deltablossom = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Verify data structures for delta2/delta3 computation.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> (CHECK_DELTA) {
					checkDelta2();
					checkDelta3();
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute delta1: the minumum value of any vertex dual.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> (!maxcardinality) {
					deltatype = <span class="hljs-number">1</span>;
					delta = min(dualvar, <span class="hljs-number">0</span>, nvertex);
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute delta2: the minimum slack on any edge between
an S-vertex and a free vertex.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">for</span> (v = <span class="hljs-number">0</span>; v &lt; nvertex; ++v) {
					<span class="hljs-keyword">if</span> (label[inblossom[v]] === <span class="hljs-number">0</span> &amp;&amp; bestedge[v] !== -<span class="hljs-number">1</span>) {
						d = slack(bestedge[v]);
						<span class="hljs-keyword">if</span> (deltatype === -<span class="hljs-number">1</span> || d &lt; delta) {
							delta = d;
							deltatype = <span class="hljs-number">2</span>;
							deltaedge = bestedge[v];
						}
					}
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute delta3: half the minimum slack on any edge between
a pair of S-blossoms.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">for</span> (b = <span class="hljs-number">0</span>; b &lt; <span class="hljs-number">2</span> * nvertex; ++b) {
					<span class="hljs-keyword">if</span> ( blossomparent[b] === -<span class="hljs-number">1</span> &amp;&amp; label[b] === <span class="hljs-number">1</span> &amp;&amp; bestedge[b] !== -<span class="hljs-number">1</span> ) {
						kslack = slack(bestedge[b]);
						d = kslack / <span class="hljs-number">2</span>;
						<span class="hljs-keyword">if</span> (deltatype === -<span class="hljs-number">1</span> || d &lt; delta) {
							delta = d;
							deltatype = <span class="hljs-number">3</span>;
							deltaedge = bestedge[b];
						}
					}
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute delta4: minimum z variable of any T-blossom.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">for</span> (b = nvertex; b &lt; <span class="hljs-number">2</span> * nvertex; ++b) {
					<span class="hljs-keyword">if</span> ( blossombase[b] &gt;= <span class="hljs-number">0</span> &amp;&amp; blossomparent[b] === -<span class="hljs-number">1</span> &amp;&amp; label[b] === <span class="hljs-number">2</span> &amp;&amp;
						(deltatype === -<span class="hljs-number">1</span> || dualvar[b] &lt; delta) ) {
						delta = dualvar[b];
						deltatype = <span class="hljs-number">4</span>;
						deltablossom = b;
					}
				}

				<span class="hljs-keyword">if</span> (deltatype === -<span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No further improvement possible; max-cardinality optimum
reached. Do a final delta update to make the optimum
verifyable.</p></div></div><div class="code"><div class="wrapper">					assert(maxcardinality);
					deltatype = <span class="hljs-number">1</span>;
					delta = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, min(dualvar, <span class="hljs-number">0</span>, nvertex));
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update dual variables according to delta.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">for</span> (v = <span class="hljs-number">0</span>; v &lt; nvertex; ++v) {
					<span class="hljs-keyword">if</span> (label[inblossom[v]] === <span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>S-vertex: 2<em>u = 2</em>u - 2*delta</p></div></div><div class="code"><div class="wrapper">						dualvar[v] -= delta;
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label[inblossom[v]] === <span class="hljs-number">2</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>T-vertex: 2<em>u = 2</em>u + 2*delta</p></div></div><div class="code"><div class="wrapper">						dualvar[v] += delta;
					}
				}
				<span class="hljs-keyword">for</span> (b = nvertex; b &lt; <span class="hljs-number">2</span> * nvertex; ++b) {
					<span class="hljs-keyword">if</span> (blossombase[b] &gt;= <span class="hljs-number">0</span> &amp;&amp; blossomparent[b] === -<span class="hljs-number">1</span>){
						<span class="hljs-keyword">if</span> (label[b] === <span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>top-level S-blossom: z = z + 2*delta</p></div></div><div class="code"><div class="wrapper">							dualvar[b] += delta;
						}
						<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label[b] === <span class="hljs-number">2</span>){</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>top-level T-blossom: z = z - 2*delta</p></div></div><div class="code"><div class="wrapper">							dualvar[b] -= delta;
						}
					}
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take action at the point where minimum delta occurred.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> (DEBUG) DEBUG(<span class="hljs-string">'delta'</span> + deltatype + <span class="hljs-string">'='</span> + delta);
				<span class="hljs-keyword">if</span> (deltatype === <span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No further improvement possible; optimum reached.</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">break</span>;
				}
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deltatype === <span class="hljs-number">2</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use the least-slack edge to continue the search.</p></div></div><div class="code"><div class="wrapper">					allowedge[deltaedge] = <span class="hljs-literal">true</span>;
					i  = edges[deltaedge][<span class="hljs-number">0</span>];
					j  = edges[deltaedge][<span class="hljs-number">1</span>];
					wt = edges[deltaedge][<span class="hljs-number">2</span>];
					<span class="hljs-keyword">if</span> (label[inblossom[i]] === <span class="hljs-number">0</span>){
						tmp = i;
						i = j;
						j = tmp;
					}
					assert(label[inblossom[i]] === <span class="hljs-number">1</span>);
					queue.push(i);
				}
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deltatype === <span class="hljs-number">3</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use the least-slack edge to continue the search.</p></div></div><div class="code"><div class="wrapper">					allowedge[deltaedge] = <span class="hljs-literal">true</span>;
					i  = edges[deltaedge][<span class="hljs-number">0</span>];
					j  = edges[deltaedge][<span class="hljs-number">1</span>];
					wt = edges[deltaedge][<span class="hljs-number">2</span>];
					assert(label[inblossom[i]] === <span class="hljs-number">1</span>);
					queue.push(i);
				}
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deltatype === <span class="hljs-number">4</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Expand the least-z blossom.</p></div></div><div class="code"><div class="wrapper">					expandBlossom(deltablossom, <span class="hljs-literal">false</span>);
				}
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>End of a this substage.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Stop when no more augmenting path can be found.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> (!augmented) <span class="hljs-keyword">break</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>End of a stage; expand all S-blossoms which have dualvar = 0.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> (b = nvertex; b &lt; <span class="hljs-number">2</span> * nvertex; ++b) {
				<span class="hljs-keyword">if</span> ( blossomparent[b] === -<span class="hljs-number">1</span> &amp;&amp; blossombase[b] &gt;= <span class="hljs-number">0</span>
					&amp;&amp; label[b] === <span class="hljs-number">1</span> &amp;&amp; dualvar[b] === <span class="hljs-number">0</span> ) {
					expandBlossom(b, <span class="hljs-literal">true</span>);
				}
			}
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Verify that we reached the optimum solution.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> (CHECK_OPTIMUM) verifyOptimum();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Transform mate[] such that mate[v] is the vertex to which v is paired.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> (v = <span class="hljs-number">0</span>; v &lt; nvertex; ++v) {
			<span class="hljs-keyword">if</span> (mate[v] &gt;= <span class="hljs-number">0</span>) {
				mate[v] = endpoint[mate[v]];
			}
		}
		<span class="hljs-keyword">for</span> (v = <span class="hljs-number">0</span>; v &lt; nvertex; ++v) {
			assert(mate[v] === -<span class="hljs-number">1</span> || mate[mate[v]] === v);
		}

		<span class="hljs-keyword">return</span> mate;

	};



	<span class="hljs-keyword">return</span> maxWeightMatching;


};



exports.wblossom_n3_t = wblossom_n3_t;</div></div></div></div></body></html>